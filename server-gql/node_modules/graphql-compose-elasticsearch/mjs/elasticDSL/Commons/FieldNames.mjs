/* eslint-disable no-param-reassign */
import { upperFirst, EnumTypeComposer } from 'graphql-compose';
import { getTypeName, desc } from '../../utils';
export function getStringFields(opts) {
  return getFieldNamesType(opts, ['text', 'keyword', 'string'], 'String');
}
export function getStringAsFieldConfigMap(opts, fc) {
  return getFieldConfigMap(opts, ['text', 'keyword', 'string'], fc);
}
export function getAnalyzedFields(opts) {
  return getFieldNamesType(opts, ['text', 'string'], 'String', true);
}
export function getAnalyzedAsFieldConfigMap(opts, fc) {
  return getFieldConfigMap(opts, ['text', 'string'], fc, true);
}
export function getKeywordAsFieldConfigMap(opts, fc) {
  return getFieldConfigMap(opts, ['keyword'], fc);
}
export function getNumericFields(opts) {
  return getFieldNamesType(opts, ['byte', 'short', 'integer', 'long', 'double', 'float', 'half_float', 'scaled_float', 'token_count'], 'Numeric');
}
export function getDateFields(opts) {
  return getFieldNamesType(opts, ['date'], 'Date');
}
export function getBooleanFields(opts) {
  return getFieldNamesType(opts, ['boolean'], 'Boolean');
}
export function getGeoPointFields(opts) {
  return getFieldNamesType(opts, ['geo_point'], 'GeoPoint');
}
export function getGeoPointAsFieldConfigMap(opts, fc) {
  return getFieldConfigMap(opts, ['geo_point'], fc);
}
export function getGeoShapeAsFieldConfigMap(opts, fc) {
  return getFieldConfigMap(opts, ['geo_shape'], fc);
}
export function getNestedFields(opts) {
  return getFieldNamesType(opts, ['nested'], 'Nested');
}
export function getIpFields(opts) {
  return getFieldNamesType(opts, ['ip'], 'Ip');
}
export function getPercolatorFields(opts) {
  return getFieldNamesType(opts, ['percolator'], 'Percolator');
}
export function getTermFields(opts) {
  return getFieldNamesType(opts, ['keyword', 'date', 'boolean', 'ip', 'byte', 'short', 'integer', 'long', 'double', 'float', 'half_float', 'scaled_float', 'token_count'], 'Term');
}
export function getAllFields(opts) {
  return getFieldNamesType(opts, ['_all'], 'All');
}
export function getAllAsFieldConfigMap(opts, fc) {
  return getFieldConfigMap(opts, ['_all'], fc);
}
export function getFieldNamesByElasticType(fieldMap, types) {
  const fieldNames = [];
  types.forEach(type => {
    if (typeof fieldMap[type] === 'object') {
      Object.keys(fieldMap[type]).forEach(fieldName => {
        fieldNames.push(fieldName);
      });
    }
  });
  return fieldNames;
}
export function getFieldNamesType(opts, types, typePrefix, addAll = false) {
  if (!opts || !opts.fieldMap) {
    return 'String';
  }

  if (!types) {
    types = ['_all'];
    typePrefix = 'All';
  }

  if (!typePrefix) {
    types.sort();
    typePrefix = types.map(t => upperFirst(t)).join('');
  }

  const name = getTypeName(`${typePrefix}Fields`, opts);
  const description = desc(`Avaliable fields from mapping.`);
  return opts.schemaComposer.getOrSet(name, () => {
    if (!opts || !opts.fieldMap) {
      return opts.schemaComposer.get('String');
    }

    const values = getEnumValues(opts.fieldMap, types, addAll);

    if (Object.keys(values).length === 0) {
      return opts.schemaComposer.get('String');
    }

    return opts.schemaComposer.createEnumTC({
      name,
      description,
      values
    });
  });
}

function getEnumValues(fieldMap, types, addAll = false) {
  const values = {};

  if (addAll) {
    values._all = {
      value: '_all'
    };
  }

  getFieldNamesByElasticType(fieldMap, types).forEach(fieldName => {
    values[fieldName] = {
      value: fieldName.replace(/__/g, '.')
    };
  });
  return values;
} // FieldsMap generated by this function, contain underscored field names
// So you should manually reassemble args before sending query to ElasticSearch
// for renaming { "field__subFild": 123 } to { "field.subField": 123 }
// Eg. see elasticDSL/Query/Query.js method prepareQueryInResolve()


export function getFieldConfigMap(opts, types, fc, addAll = false) {
  if (!fc) fc = 'JSON';

  if (!opts || !opts.fieldMap) {
    return 'JSON';
  }

  if (!types) {
    types = ['_all'];
  }

  const fcMap = {};

  if (addAll) {
    fcMap._all = fc;
  }

  getFieldNamesByElasticType(opts.fieldMap, types).forEach(fieldName => {
    fcMap[fieldName] = fc;
  });

  if (Object.keys(fcMap).length === 0) {
    return 'JSON';
  }

  return fcMap;
}